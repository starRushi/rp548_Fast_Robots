<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lab 1: Artemis Board and Bluetooth</title>
  <style>
    :root{
      --text:#111;
      --muted:#555;
      --rule:#d8d8d8;
      --bg:#ffffff;
      --codebg:#f6f6f6;
      --link:#0b3d91;
      --maxw: 860px;
    }
    html,body{ background:var(--bg); color:var(--text); }
    body{
      margin:0;
      font-family: "Times New Roman", Times, serif;
      line-height: 2.0;
      font-size: 18px;
    }
    .wrap{ max-width: var(--maxw); margin: 0 auto; padding: 48px 28px 72px; }
    header{ border-bottom:1px solid var(--rule); padding-bottom: 18px; margin-bottom: 26px; }
    .crumbs{ font-size: 16px; color: var(--muted); }
    .crumbs a{ color: var(--link); text-decoration: none; }
    .crumbs a:hover{ text-decoration: underline; }
    h1{ font-size: 28px; margin: 6px 0 0; line-height: 1.4; }
    .meta{ color: var(--muted); font-size: 16px; margin-top: 6px; }
    h2{ font-size: 22px; margin: 34px 0 8px; }
    h3{ font-size: 19px; margin: 26px 0 6px; }
    p{ margin: 10px 0; }
    ul{ margin: 10px 0 10px 26px; }
    li{ margin: 6px 0; }
    hr{ border:0; border-top:1px solid var(--rule); margin: 26px 0; }
    .callout{
      border:1px solid var(--rule);
      padding: 14px 16px;
      background: #fcfcfc;
      margin: 16px 0;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px 18px;
    }
    .kv{
      border:1px solid var(--rule);
      padding: 12px 14px;
      background:#fff;
    }
    .kv b{ display:block; font-weight:700; margin-bottom: 4px; }
    code, pre{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    pre{
      background: var(--codebg);
      border:1px solid var(--rule);
      padding: 12px 14px;
      overflow:auto;
      margin: 12px 0;
    }
    .figure{
      border:1px solid var(--rule);
      padding: 10px;
      background:#fff;
      margin: 12px 0;
    }
    .figure img, .figure video{
      max-width:100%;
      display:block;
      margin: 0 auto;
    }
    .caption{
      color: var(--muted);
      font-size: 15px;
      margin-top: 8px;
      line-height: 1.6;
    }
    .task{
      border-top:1px solid var(--rule);
      padding-top: 18px;
      margin-top: 18px;
    }
    .tight{ margin-top: 0; }
    .small{ font-size:16px; color:var(--muted); }
    @media (max-width: 760px){
      .grid{ grid-template-columns: 1fr; }
      body{ font-size: 17px; }
      .wrap{ padding: 36px 18px 60px; }
    }
    .video-container{
      position: relative;
      width: 100%;
      padding-top: 56.25%;
      border:1px solid var(--rule);
      background:#fff;
      margin: 12px 0;
    }
    .video-container iframe{
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      border:0;
    }

  </style>
</head>

<body>
  <div class="wrap">
<!-- You're reading the HTML of a burnt out college student written at 4am so either you have no life, you're my friend from the future, or your the professor checking that I actually did this legit. Hi professor. Yes I did. It was really hard. Your class is super cool though, and your vibes are 10/10 -->
    <header>
      <div class="crumbs">
        <a href="/">Fast Robots @ Cornell</a> &nbsp;›&nbsp; <span>Lab 1</span>
      </div>
      <h1>Lab 1: The Artemis Board and Bluetooth</h1>
      <div class="meta">
        <span>Board: SparkFun RedBoard Artemis Nano</span> ·
        <span>Interface: USB Serial + BLE</span> ·
      </div>
    </header>

    <section>
      <h2>Overview</h2>
      <p>
        <span class="small">Over the course of two weeks, we performed labs 1a and 1b, to familiarize ourselves with the Arduino IDE, programming the Artemis board, and bluetooth connection. </span>
      </p>
    </section>

    <section>
      <h2>Prelab</h2>

      <h3>Setup</h3>
      <div class="grid">
        <div class="kv">
          <b>Arduino IDE and Board Support</b>
          <div class="small">
            IDE version: 2.3.7 · Apollo boards manager: SparkFun Apollo3 Boards · Port/Board selection verified.
          </div>
        </div>
        <div class="kv">
          <b>Artemis MAC Address</b>
          <div class="small">
            MAC printed in Serial Monitor: <code>[fill: c0:81:a4:24:29:64]</code>
          </div>
        </div>
        <div class="kv">
          <b>BLE Service UUID</b>
          <div class="small">
            Generated UUID used to avoid cross-connecting: <code>84b22398-9ffc-4b89-aa8f-b9d6956d5dd9</code>
          </div>
        </div>
      </div>

      <div class="figure">
        <!-- Replace src with your path, e.g. /assets/lab1/mac_serial.png -->
        <img src="[put-image-path-here]" alt="Serial monitor showing MAC address" />
        <div class="caption">Figure: Artemis prints its MAC address after flashing the BLE sketch (115200 baud).</div>
      </div>

    <section>
      <h2>Lab 1a Tasks</h2>
      
        <h3>Task 1: Blink</h3>
      
        <p>
          The Blink example was used to confirm successful code upload and execution on the Artemis board. The delay was modified to ten seconds between each blink to make the LED state change clearly observable.
        </p>
      
        <div class="video-container">
          <iframe
            src="https://www.youtube.com/embed/v8B0xYWBlfY?si=Mh6JG7_IXRL1cB9t"
            title="Blink Verification"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen>
          </iframe>
        </div>
      
        <p class="caption">
          Video: Serial monitor output and LED behavior during Blink execution.
        </p>

        
        <h3>Task 2: Serial</h3>
      
        <p>
          The serial communication example was run to verify bidirectional data transfer between the Artemis board and the computer. Messages sent from the board were observed in the serial monitor at the expected baud rate of 115200.
        </p>
      
        <div class="video-container">
          <iframe
            src="https://www.youtube.com/embed/mRQXTr-keY4?si=4t2he5kul8XjJxis"
            title="Serial Verification"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen>
          </iframe>
        </div>
      
        <p class="caption">
          Video: Serial monitor output showing connection. 
        </p>


        <h3>Task 3: analogRead</h3>
      
        <p>
          The onboard temperature sensor was tested using the provided analog read example. Temperature readings changed when the chip was touched by hand and when air was blown across the board, confirming that the sensor was responsive.
        </p>
      
        <div class="video-container">
          <iframe
            src="https://www.youtube.com/embed/umYwenaJS8k?si=mm2z8U5HMKipUv5l"
            title="Blink Verification"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen>
          </iframe>
        </div>
      
        <p class="caption">
          Video: Serial monitor output while blowing temp sensor.
        </p>


        <h3>Task 4: MicrophoneOutput</h3>
      
        <p>
          The pulse density microphone example was used to test audio input on the Artemis board. Changes in the serial output were observed when whistling near the microphone, indicating successful detection of sound frequency and amplitude.
        </p>
      
        <div class="video-container">
          <iframe
            src="https://www.youtube.com/embed/9U9Axbdbj5Q?si=F-rwMQRM09DystjL"
            title="Blink Verification"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen>
          </iframe>
        </div>
      
        <p class="caption">
          Video: Serial monitor output during sound testing.
        </p>


<!-- LAB 2 BEGINS HERE -->
<!-- LAB 2 BEGINS HERE -->
<!-- LAB 2 BEGINS HERE -->
      
      <h2>Lab 1b Tasks</h2>
      
      <h3>Configurations</h3>
      <p class="small">
        Note that the artemis address had to be temporarily changed when, in lab, a different board was used. As always, baud rate was set to 115200. 
      </p>

      <pre><code># connections.yaml 
artemis_address: 'c0:81:a4:24:29:64'
ble_service: '84b22398-9ffc-4b89-aa8f-b9d6956d5dd9'
characteristics:
  TX_CMD_STRING: '9750f60b-9c9c-4158-b620-02ec9521cd99'
  RX_FLOAT: '27616294-3063-4ecc-b60b-3470ddef2938'
  RX_STRING: 'f235a225-6735-4d73-94cb-ee5dfce9ba83'</code></pre>

      <div class="grid">
        <div class="figure">
          <img src="[put-image-path-here]" alt="connections.yaml excerpt" />
          <div class="caption">Figure: YAML configuration used by the Python BLE client.</div>
        </div>
        <div class="figure">
          <img src="[put-image-path-here]" alt="Arduino serial monitor showing advertising and MAC" />
          <div class="caption">Figure: Artemis serial output confirming BLE advertising and MAC address.</div>
        </div>
      </div>

      <h3>Codebase: BLE architecture and how commands flow</h3>
      <p>
        The BLE codebase is split into an Arduino peripheral and a Python central. On the Artemis, a BLE service is advertised with multiple characteristics.
        The laptop connects to that service, writes commands to a writable string characteristic, and subscribes to notify-enabled characteristics to receive replies.
        Commands are encoded as a single string with a numeric command type followed by optional values separated by delimiters. On the Artemis, the RobotCommand
        class tokenizes the received string to extract the command type and values. Replies are sent back either as a string (for structured text like timestamps)
        or as a float (for numerical telemetry), using notify so the laptop receives data asynchronously without polling.
      </p>

      <pre><code># Jupyter setup (minimal)
%load_ext autoreload
%autoreload 2

from ble import get_ble_controller
from cmd_types import CMD
import time

ble = get_ble_controller()
ble.connect()</code></pre>

      <div class="task">
        <h3>Task 1: ECHO command round-trip</h3>
        <p class="small">
          The laptop sends an ECHO command with a payload string. The Artemis extracts the payload and writes it back on the notify string characteristic.
        </p>

        <pre><code>// Arduino (ECHO)
case ECHO: {

    char char_arr[MAX_MSG_SIZE];

    success = robot_cmd.get_next_value(char_arr);
    if (!success)
        return;

    Serial.print("ECHO: ");
    Serial.print(char_arr);

    tx_estring_value.clear();
    tx_estring_value.append(char_arr);
    tx_characteristic_string.writeValue(tx_estring_value.c_str());

    break;
}</code></pre>

        <pre><code># Jupyter (ECHO)
ble.send_command(CMD.ECHO, "hi mate")
s = ble.receive_string(ble.uuid["RX_STRING"])
print(s)</code></pre>

        <div class="grid">
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 1 Jupyter output" />
            <div class="caption">Figure: Jupyter output showing echoed string returned over BLE.</div>
          </div>
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 1 serial output" />
            <div class="caption">Figure: Artemis serial output showing the received payload.</div>
          </div>
        </div>
      </div>

      <div class="task">
        <h3>Task 2: SEND_THREE_FLOATS parsing on Artemis</h3>
        <p class="small">
          The laptop sends three floats separated by <code>|</code>. The Artemis extracts three floats and verifies correct parsing via serial output.
        </p>

        <pre><code>// Arduino (SEND_THREE_FLOATS)
case SEND_THREE_FLOATS: {

    float fl_a, fl_b, fl_c;

    success = robot_cmd.get_next_value(fl_a);
    if (!success)
        return;

    success = robot_cmd.get_next_value(fl_b);
    if (!success)
        return;

    success = robot_cmd.get_next_value(fl_c);
    if (!success)
        return;

    Serial.print("Three Floats: ");
    Serial.print(fl_a);
    Serial.print(", ");
    Serial.print(fl_b);
    Serial.print(", ");
    Serial.print(fl_c);
    Serial.print(", ");

    break;
}</code></pre>

        <pre><code># Jupyter (SEND_THREE_FLOATS)
ble.send_command(CMD.SEND_THREE_FLOATS, "3.1|23.9|1.1")</code></pre>

        <div class="grid">
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 2 serial output" />
            <div class="caption">Figure: Artemis serial output confirming correct float extraction order.</div>
          </div>
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 2 Jupyter output" />
            <div class="caption">Figure: Jupyter cell used to transmit the three-float command.</div>
          </div>
        </div>
      </div>

      <div class="task">
        <h3>Task 3: GET_TIME_MILLIS returns a timestamp string</h3>
        <p class="small">
          The Artemis replies to GET_TIME_MILLIS with a string containing the current millisecond counter.
        </p>

        <pre><code>// Arduino (GET_TIME_MILLIS)
case GET_TIME_MILLIS: {

    int TIME;
    TIME = millis();

    Serial.print("T:");
    Serial.println(millis());

    tx_estring_value.clear();
    tx_estring_value.append("T:");
    tx_estring_value.append(TIME);
    tx_characteristic_string.writeValue(tx_estring_value.c_str());

    break;
}</code></pre>

        <pre><code># Jupyter (GET_TIME_MILLIS)
ble.send_command(CMD.GET_TIME_MILLIS, "")
s = ble.receive_string(ble.uuid["RX_STRING"])
print(s)</code></pre>

        <div class="grid">
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 3 Jupyter output" />
            <div class="caption">Figure: Timestamp string received in Jupyter from the RX_STRING notify characteristic.</div>
          </div>
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 3 serial output" />
            <div class="caption">Figure: Artemis serial output showing the same timestamp being generated.</div>
          </div>
        </div>
      </div>

      <div class="task">
        <h3>Task 4: Notification handler parses time values</h3>
        <p class="small">
          A notification callback was registered on the string characteristic. Each notification is decoded and the millisecond field is extracted.
        </p>

        <pre><code># Jupyter (notification handler for RX_STRING)
def parse_t(s):
    return int(s.split(":", 1)[1])

def handler(uuid, notif):
    s = ble.bytearray_to_string(notif).strip()
    print(parse_t(s))

ble.start_notify(ble.uuid["RX_STRING"], handler)  # run once per kernel session</code></pre>

        <div class="grid">
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 4 Jupyter output" />
            <div class="caption">Figure: Handler output printing parsed millisecond values.</div>
          </div>
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 4 serial output" />
            <div class="caption">Figure: Artemis serial output during notification testing.</div>
          </div>
        </div>
      </div>

      <div class="task">
        <h3>Task 5: Message throughput measurement</h3>
        <p class="small">
          The Artemis repeatedly writes a float notification for a fixed window, counts the number of writes, and reports the average rate in messages per second.
        </p>

        <pre><code>// Arduino (MESSAGE_SPEED)
case MESSAGE_SPEED: {

    speed_test_active = true;

    unsigned long start_ms = millis();
    unsigned long now_ms = start_ms;

    int count = 0;

    while ((now_ms - start_ms) &lt; 10000) {
        now_ms = millis();

        tx_characteristic_float.writeValue(1.0f);

        count++;

        delay(1);
    }

    float rate = count / 10.0f;

    Serial.print("Messages Per Second are ");
    Serial.println(rate);
    Serial.print("every second, averaged over 10 seconds.");

    speed_test_active = false;

    break;
}</code></pre>

        <pre><code># Jupyter (trigger MESSAGE_SPEED)
def float_handler(uuid, notif):
    pass

ble.start_notify(ble.uuid["RX_FLOAT"], float_handler)
ble.send_command(CMD.MESSAGE_SPEED, "")</code></pre>

        <div class="grid">
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 5 serial output" />
            <div class="caption">Figure: Artemis serial output reporting average messages per second over the 10 second window.</div>
          </div>
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 5 Jupyter output" />
            <div class="caption">Figure: Jupyter run used to open RX_FLOAT notifications and trigger the speed test.</div>
          </div>
        </div>

        <div class="callout">
          <b>Effective data transfer rate</b>
          <div class="small">
            Measured notification rate: <code>[fill: msgs/sec]</code><br>
            Float payload rate (payload only): <code>(msgs/sec) × 4 bytes</code> = <code>[fill: bytes/sec]</code><br>
            Note: BLE overhead is nonzero and is not included in payload-only throughput.
          </div>
        </div>
      </div>

      <div class="task">
        <h3>Task 6: Buffered timestamp array and SEND_TIME_DATA</h3>
        <p class="small">
          Instead of streaming each timestamp immediately, timestamps are stored into a global fixed-size buffer during a recording window.
          After recording, SEND_TIME_DATA transmits each stored timestamp as a string to the laptop.
        </p>

        <pre><code>// Arduino globals (buffers)
const int TIME_BUF_LEN = 2000;

unsigned long time_buf[TIME_BUF_LEN];
int time_buf_count = 0;

float temp_buf[TIME_BUF_LEN];</code></pre>

        <pre><code>// Arduino (RECORD_TIME_DATA)
case RECORD_TIME_DATA: {

    time_buf_count = 0;

    unsigned long start_ms = millis();
    unsigned long now_ms = start_ms;

    while ((now_ms - start_ms) &lt; 10000) {
        now_ms = millis();

        if (time_buf_count &gt;= TIME_BUF_LEN) {
            break;
        }

        time_buf[time_buf_count] = now_ms;

        float tC = getTempDegC();
        temp_buf[time_buf_count] = tC;

        time_buf_count++;

        delay(1);
    }

    Serial.print("RECORDED ");
    Serial.print(time_buf_count);
    Serial.println(" (time,temp) samples");

    break;
}</code></pre>

        <pre><code>// Arduino (SEND_TIME_DATA)
case SEND_TIME_DATA: {

    for (int i = 0; i &lt; time_buf_count; i++) {
        tx_estring_value.clear();
        tx_estring_value.append("T:");
        tx_estring_value.append((int)time_buf[i]);
        tx_characteristic_string.writeValue(tx_estring_value.c_str());
        delay(2);
    }

    tx_characteristic_string.writeValue("Jupyter ping task 6 done");

    break;
}</code></pre>

        <pre><code># Jupyter (Task 6 receive)
time_list = []

def time_handler(uuid, notif):
    s = ble.bytearray_to_string(notif).strip()
    if s.startswith("T:"):
        time_list.append(int(s.split(":", 1)[1]))
    else:
        print(s, "received:", len(time_list))

ble.start_notify(ble.uuid["RX_STRING"], time_handler)

time_list.clear()
ble.send_command(CMD.RECORD_TIME_DATA, "")
ble.send_command(CMD.SEND_TIME_DATA, "")</code></pre>

        <div class="grid">
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 6 Jupyter output" />
            <div class="caption">Figure: Jupyter output showing the final count of timestamps received.</div>
          </div>
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 6 serial output" />
            <div class="caption">Figure: Artemis serial output confirming buffer fill count during recording.</div>
          </div>
        </div>
      </div>

      <div class="task">
        <h3>Task 7: Buffered temperature readings paired with timestamps</h3>
        <p class="small">
          A second buffer stores temperature values at the same indices as the timestamp buffer. GET_TEMP_READINGS transmits paired records formatted as
          <code>T:&lt;ms&gt;|C:&lt;degC&gt;</code>. The laptop parses the pairs into two lists.
        </p>

        <pre><code>// Arduino (GET_TEMP_READINGS)
case GET_TEMP_READINGS: {

    for (int i = 0; i &lt; time_buf_count; i++) {

        tx_estring_value.clear();
        tx_estring_value.append("T:");
        tx_estring_value.append((int)time_buf[i]);
        tx_estring_value.append("|C:");
        tx_estring_value.append(temp_buf[i]);

        tx_characteristic_string.writeValue(tx_estring_value.c_str());
        delay(2);
    }

    tx_characteristic_string.writeValue("DONE");
    Serial.println("SENT TEMP READINGS");

    break;
}</code></pre>

        <pre><code># Jupyter (Task 7 receive)
time_list = []
temp_list = []

def temp_handler(uuid, notif):
    s = ble.bytearray_to_string(notif).strip()
    if s == "DONE":
        print("DONE", len(time_list), len(temp_list))
        return
    if s.startswith("T:") and "|C:" in s:
        left, right = s.split("|C:", 1)
        t = int(left.split(":", 1)[1])
        c = float(right)
        time_list.append(t)
        temp_list.append(c)

ble.start_notify(ble.uuid["RX_STRING"], temp_handler)

time_list.clear()
temp_list.clear()
ble.send_command(CMD.RECORD_TIME_DATA, "")
ble.send_command(CMD.GET_TEMP_READINGS, "")</code></pre>

        <div class="grid">
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 7 Jupyter output" />
            <div class="caption">Figure: Jupyter output showing paired timestamp and temperature parsing.</div>
          </div>
          <div class="figure">
            <img src="[put-image-path-here]" alt="Task 7 serial output" />
            <div class="caption">Figure: Artemis serial output confirming the temperature dataset was transmitted.</div>
          </div>
        </div>

        <div class="figure">
          <img src="[put-image-path-here]" alt="Temperature vs time plot" />
          <div class="caption">Figure: Temperature plotted versus time using the parsed lists.</div>
        </div>
      </div>

      <h2>Discussion</h2>
      <h3>Live streaming vs buffered acquisition</h3>
      <p>
        Streaming sends each data point immediately as it is sampled, which supports interactive debugging and low latency feedback, but increases BLE traffic and
        makes performance sensitive to notification overhead and packet loss. Buffered acquisition records samples locally at a steady cadence and transmits later,
        which reduces real-time BLE load during sampling and can improve reliability, but introduces delay between acquisition and inspection and is constrained by RAM.
      </p>

      <div class="callout">
        <b>Sampling speed and memory estimate</b>
        <div class="small">
          Buffered sampling cadence is limited by the loop body and any explicit delays.
          With <code>delay(1)</code>, the theoretical upper bound is approximately 1000 samples per second, with the actual value dependent on sensor read time and BLE state.<br><br>
          Memory used by buffers (payload only):<br>
          <code>time_buf</code>: <code>TIME_BUF_LEN × 4 bytes</code><br>
          <code>temp_buf</code>: <code>TIME_BUF_LEN × 4 bytes</code><br>
          Total: <code>TIME_BUF_LEN × 8 bytes</code><br>
          For <code>TIME_BUF_LEN = 2000</code>, buffer payload is approximately <code>16,000 bytes</code> (about <code>15.6 kB</code>), excluding overhead and other variables, within 384 kB RAM.
        </div>
      </div>

      <div class="figure">
        <img src="[put-image-path-here]" alt="Optional summary screenshot" />
        <div class="caption">Figure: Optional summary evidence showing final received list sizes and consistency checks.</div>
      </div>

    </section>

  </div>
</body>
</html>

